name: Build Windows Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version_bump:
        description: '版本递增类型（none = 仅构建不发布）'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
          - none
        default: patch
      create_release:
        description: '是否创建 GitHub Release（仅 version_bump 非 none 时生效）'
        required: true
        type: boolean
        default: true

env:
  CARGO_TERM_COLOR: always

jobs:
  build:
    runs-on: windows-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      create_release: ${{ github.event_name == 'push' || (github.event.inputs.version_bump != 'none' && github.event.inputs.create_release == 'true') }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get version and create tag
        id: version
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            # tag push: 从 ref 中提取
            TAG_NAME=${GITHUB_REF#refs/tags/}
            VERSION=${TAG_NAME#v}
          else
            BUMP="${{ github.event.inputs.version_bump }}"

            if [ "$BUMP" = "none" ]; then
              # 仅构建，不创建 tag
              SHORT_SHA=$(git rev-parse --short HEAD)
              echo "tag=" >> $GITHUB_OUTPUT
              echo "version=dev-$SHORT_SHA" >> $GITHUB_OUTPUT
              echo "仅构建模式，版本号: dev-$SHORT_SHA"
              exit 0
            fi

            # 获取最新的 tag 版本号
            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            if [ -z "$LATEST_TAG" ]; then
              LATEST_VERSION="0.0.0"
            else
              LATEST_VERSION=${LATEST_TAG#v}
            fi

            # 解析 major.minor.patch
            IFS='.' read -r MAJOR MINOR PATCH <<< "$LATEST_VERSION"
            MAJOR=${MAJOR:-0}; MINOR=${MINOR:-0}; PATCH=${PATCH:-0}

            # 递增版本号
            case "$BUMP" in
              major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0 ;;
              minor) MINOR=$((MINOR + 1)); PATCH=0 ;;
              patch) PATCH=$((PATCH + 1)) ;;
            esac

            VERSION="${MAJOR}.${MINOR}.${PATCH}"
            TAG_NAME="v${VERSION}"

            echo "版本递增: $LATEST_TAG -> $TAG_NAME ($BUMP)"

            # 创建并推送 tag
            git tag "$TAG_NAME"
            git push origin "$TAG_NAME"
            echo "Tag $TAG_NAME 已创建并推送"
          fi

          echo "tag=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Tag: $TAG_NAME, Version: $VERSION"

      - name: Get changelog
        if: steps.version.outputs.tag != ''
        id: changelog
        shell: bash
        run: |
          CURRENT_TAG="${{ steps.version.outputs.tag }}"

          # 获取当前 tag 的上一个 tag
          PREV_TAG=$(git describe --tags --abbrev=0 "${CURRENT_TAG}^" 2>/dev/null || echo "")

          if [ -z "$PREV_TAG" ]; then
            # 如果没有上一个 tag，获取该 tag 最近 20 条提交
            COMMITS=$(git log --pretty=format:"- %s" -20 "${CURRENT_TAG}")
          else
            # 获取两个 tag 之间的提交
            COMMITS=$(git log --pretty=format:"- %s" "${PREV_TAG}..${CURRENT_TAG}")
          fi

          # 写入到文件避免多行问题
          echo "$COMMITS" > changelog.txt
          echo "Generated changelog (${PREV_TAG:-beginning}..${CURRENT_TAG}):"
          cat changelog.txt

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@1.93.0

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: src-tauri
        continue-on-error: true

      - name: Install Node dependencies
        run: npm ci

      - name: Download FFmpeg
        shell: pwsh
        run: |
          $ffmpegUrl = "https://www.gyan.dev/ffmpeg/builds/ffmpeg-git-full.7z"
          $ffmpegArchive = "ffmpeg.7z"
          $ffmpegTemp = "ffmpeg-temp"

          Write-Host "Downloading FFmpeg..."
          Invoke-WebRequest -Uri $ffmpegUrl -OutFile $ffmpegArchive

          Write-Host "Extracting FFmpeg (full)..."
          $sevenZip = (Get-Command 7z -ErrorAction SilentlyContinue).Source
          if (-not $sevenZip) {
            throw "7z not found in PATH"
          }
          New-Item -ItemType Directory -Path "$ffmpegTemp" -Force | Out-Null
          & $sevenZip x "-o$ffmpegTemp" "-y" "$ffmpegArchive" | Out-Host

          # Find the extracted folder and move binaries
          $extractedDir = Get-ChildItem -Path "$ffmpegTemp" -Directory | Select-Object -First 1
          New-Item -ItemType Directory -Path "ffmpeg" -Force | Out-Null

          Copy-Item "$($extractedDir.FullName)/bin/ffmpeg.exe" "ffmpeg/"
          Copy-Item "$($extractedDir.FullName)/bin/ffprobe.exe" "ffmpeg/"

          # Cleanup
          Remove-Item "$ffmpegArchive" -Force
          Remove-Item "$ffmpegTemp" -Recurse -Force

          Write-Host "FFmpeg ready:"
          Get-ChildItem "ffmpeg"

      - name: Download fpcalc (Chromaprint)
        shell: pwsh
        run: |
          $fpcalcUrl = "https://github.com/acoustid/chromaprint/releases/download/v1.6.0/chromaprint-fpcalc-1.6.0-windows-x86_64.zip"
          $fpcalcZip = "fpcalc.zip"

          Write-Host "Downloading fpcalc..."
          Invoke-WebRequest -Uri $fpcalcUrl -OutFile $fpcalcZip

          Write-Host "Extracting fpcalc..."
          Expand-Archive -Path $fpcalcZip -DestinationPath "fpcalc-temp" -Force

          # Find and copy fpcalc.exe
          $fpcalcExe = Get-ChildItem -Path "fpcalc-temp" -Recurse -Filter "fpcalc.exe" | Select-Object -First 1
          Copy-Item $fpcalcExe.FullName "ffmpeg\"

          # Cleanup
          Remove-Item $fpcalcZip -Force
          Remove-Item "fpcalc-temp" -Recurse -Force

          Write-Host "fpcalc ready:"
          Get-ChildItem "ffmpeg"

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12.9'

      - name: Build audio-separator package
        shell: pwsh
        run: |
          Write-Host "Creating Python virtual environment..."
          python -m venv tools\venv

          Write-Host "Installing PyTorch CUDA 12.8 (required by audio-separator for GPU acceleration)..."
          .\tools\venv\Scripts\pip.exe install torch==2.10.0 torchvision==0.22.0 --index-url https://download.pytorch.org/whl/cu128

          Write-Host "Installing ONNX Runtime GPU with CUDA runtime..."
          .\tools\venv\Scripts\pip.exe install "onnxruntime-gpu[cuda,cudnn]==1.22.0"

          Write-Host "Installing audio-separator and PyInstaller..."
          .\tools\venv\Scripts\pip.exe install audio-separator==0.41.1 pyinstaller==6.13.0

          Write-Host "Building audio-separator executable..."
          .\tools\venv\Scripts\python.exe .\scripts\build_audio_separator.py

          Write-Host "audio-separator package ready:"
          Get-ChildItem "src-tauri\resources\audio-separator" -ErrorAction SilentlyContinue

      - name: Download MDX-Net model and config files
        shell: pwsh
        run: |
          $modelDir = "models\audio-separator\mdx-inst-hq3"
          $modelFile = "UVR-MDX-NET-Inst_HQ_3.onnx"
          $modelUrl = "https://github.com/TRvlvr/model_repo/releases/download/all_public_uvr_models/$modelFile"
          $dataUrlPrefix = "https://raw.githubusercontent.com/TRvlvr/application_data/main"

          Write-Host "Creating model directory..."
          New-Item -ItemType Directory -Path $modelDir -Force | Out-Null

          Write-Host "Downloading MDX-Net model ($modelFile)..."
          Invoke-WebRequest -Uri $modelUrl -OutFile "$modelDir\$modelFile"

          Write-Host "Downloading model config files..."
          Invoke-WebRequest -Uri "$dataUrlPrefix/mdx_model_data/model_data_new.json" -OutFile "$modelDir\mdx_model_data.json"
          Invoke-WebRequest -Uri "$dataUrlPrefix/vr_model_data/model_data_new.json" -OutFile "$modelDir\vr_model_data.json"
          Invoke-WebRequest -Uri "$dataUrlPrefix/filelists/download_checks.json" -OutFile "$modelDir\download_checks.json"

          Write-Host "Model and config files downloaded:"
          Get-ChildItem $modelDir

      - name: Build Tauri application
        shell: pwsh
        run: |
          $env:PATH = "$PWD\ffmpeg;$env:PATH"
          npm run tauri:build

      - name: Create FFmpeg Package
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.version }}"
          $outputDir = "dist/MusicCut-FFmpeg"
          $archiveName = "MusicCut_${version}_x64_FFmpeg.7z"
          $outputFolder = Split-Path -Leaf $outputDir

          Write-Host "Creating FFmpeg package..."

          # Create output directory
          New-Item -ItemType Directory -Path "$outputDir" -Force | Out-Null

          # Copy main exe
          Copy-Item "src-tauri/target/release/MusicCut.exe" "$outputDir"

          # Copy WebView2Loader.dll if exists
          if (Test-Path "src-tauri/target/release/WebView2Loader.dll") {
            Copy-Item "src-tauri/target/release/WebView2Loader.dll" "$outputDir"
          }

          # Copy FFmpeg
          Copy-Item -Recurse "ffmpeg" "$outputDir/ffmpeg"

          # Copy models if exist
          if (Test-Path "models") {
            Copy-Item -Recurse "models" "$outputDir/models"
          }

          # Copy audio-separator
          if (Test-Path "src-tauri/resources/audio-separator") {
            Copy-Item -Recurse "src-tauri/resources/audio-separator" "$outputDir/audio-separator"
          }

          # Create 7z archive (avoid nesting dist/ in the archive)
          Push-Location "dist"
          7z a -t7z -mx=9 "$archiveName" "$outputFolder"
          Pop-Location

          Write-Host "FFmpeg package created: dist/$archiveName"
          Get-ChildItem "dist/*.7z"

      - name: Create NoFFmpeg Package
        shell: pwsh
        run: |
          $version = "${{ steps.version.outputs.version }}"
          $outputDir = "dist/MusicCut-NoFFmpeg"
          $archiveName = "MusicCut_${version}_x64_NoFFmpeg.7z"
          $outputFolder = Split-Path -Leaf $outputDir

          Write-Host "Creating NoFFmpeg package..."

          # Create output directory
          New-Item -ItemType Directory -Path "$outputDir" -Force | Out-Null

          # Copy main exe
          Copy-Item "src-tauri/target/release/MusicCut.exe" "$outputDir"

          # Copy WebView2Loader.dll if exists
          if (Test-Path "src-tauri/target/release/WebView2Loader.dll") {
            Copy-Item "src-tauri/target/release/WebView2Loader.dll" "$outputDir"
          }

          # Copy models if exist
          if (Test-Path "models") {
            Copy-Item -Recurse "models" "$outputDir/models"
          }

          # Copy audio-separator
          if (Test-Path "src-tauri/resources/audio-separator") {
            Copy-Item -Recurse "src-tauri/resources/audio-separator" "$outputDir/audio-separator"
          }

          # Create 7z archive (avoid nesting dist/ in the archive)
          Push-Location "dist"
          7z a -t7z -mx=9 "$archiveName" "$outputFolder"
          Pop-Location

          Write-Host "NoFFmpeg package created: dist/$archiveName"
          Get-ChildItem "dist/*.7z"

      - name: List artifacts
        shell: pwsh
        run: |
          Write-Host "=== Build Artifacts ==="
          Get-ChildItem "dist\*.7z" | ForEach-Object {
            $sizeMB = [math]::Round($_.Length / 1MB, 2)
            Write-Host "$($_.Name) - $sizeMB MB"
          }

      - name: Upload FFmpeg Package
        uses: actions/upload-artifact@v4
        with:
          name: MusicCut_${{ steps.version.outputs.version }}_x64_FFmpeg
          path: dist/MusicCut_${{ steps.version.outputs.version }}_x64_FFmpeg.7z
          compression-level: 0
          retention-days: 30

      - name: Upload NoFFmpeg Package
        uses: actions/upload-artifact@v4
        with:
          name: MusicCut_${{ steps.version.outputs.version }}_x64_NoFFmpeg
          path: dist/MusicCut_${{ steps.version.outputs.version }}_x64_NoFFmpeg.7z
          compression-level: 0
          retention-days: 30

      - name: Upload changelog
        uses: actions/upload-artifact@v4
        with:
          name: changelog
          path: changelog.txt
          retention-days: 1

  release:
    needs: build
    if: needs.build.outputs.create_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Read changelog
        id: changelog
        run: |
          if [ -f "artifacts/changelog/changelog.txt" ]; then
            CHANGELOG=$(cat artifacts/changelog/changelog.txt)
          else
            CHANGELOG="- Initial release"
          fi
          # 使用 EOF 处理多行
          echo "content<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: List downloaded artifacts
        run: |
          echo "=== Downloaded Artifacts ==="
          echo "Full directory structure:"
          find artifacts -type f
          echo ""
          echo "7z files:"
          find artifacts -type f -name "*.7z" | while read f; do
            size=$(du -h "$f" | cut -f1)
            echo "$f - $size"
          done

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.build.outputs.tag }}
          name: MusicCut ${{ needs.build.outputs.tag }}
          body: |
            ## 更新日志

            ${{ steps.changelog.outputs.content }}

            ---

            ## 下载说明

            | 版本 | 说明 | 适用场景 |
            |:---:|:---|:---|
            | **FFmpeg** | 完整版，包含 FFmpeg | 推荐大多数用户使用 |
            | **NoFFmpeg** | 精简版，不含 FFmpeg | 已安装 FFmpeg 的用户 |

            ## 使用方法

            1. 下载对应版本的 `.7z` 文件
            2. 解压到任意目录
            3. 运行 `MusicCut.exe`

            ## NoFFmpeg 版本说明

            NoFFmpeg 版本需要自行安装 FFmpeg：
            - 下载 [FFmpeg](https://www.gyan.dev/ffmpeg/builds/)
            - 下载 [fpcalc](https://acoustid.org/chromaprint)
            - 将 `ffmpeg.exe`、`ffprobe.exe`、`fpcalc.exe` 放入程序目录的 `ffmpeg` 文件夹，或添加到系统 PATH
          files: |
            artifacts/**/*.7z
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
